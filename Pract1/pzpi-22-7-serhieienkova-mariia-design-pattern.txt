МІНЕСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмна інженерія»



ЗВІТ
до практичного заняття №1 з дисципліни
«Архітектура програмного забезпечення»







Виконала:
Ст. гр. ПЗПІ-22-7
Сергєєнкова Марія Сергіївна	Перевірив:
ст. викладач кафедри ПІ Сокорчук Ігор Петрович





Харків 2025
1.	Патерни проєктування
1.1	 Історія змін 
Зміни в документі нотуються до таблиці 1.1. 	 
 Таблиця 1.1 – Історія змін 
№	Дата змін	Версія звіту	Опис змін та виправлень
1	25.04	0.1	Створено базову структуру звіту про патерн проєктування «Visitor», додано титульну сторінку та розділ «Історія змін»
2	25.04	0.1	Створено розділ «Завдання до практичної роботи»
3	26.04	0.2	Додано розділ «Опис виконаної роботи»
4	26.04	0.2	Створено розділ «Висновки»
5	26.05	0.3	Додано додаток А з посиланням на відеоролик
6	26.05	0.3	Додано додаток Б зі слайдами презентації
7	26.05	0.3	Додано додаток В з використовуваним кодом

2.	Завдання до практичної роботи 
У межах даної практичної роботи потрібно дослідити патерн проєктування Visitor, підготувати презентацію, навести приклади використання за допомогою програмного коду та зробити відеозапис з поясненням.

3.	Опис виконаної роботи
У ході практичної роботи було досліджено патерн проєктування Visitor (Відвідувач). Було вивчено його структуру, основну ідею та випадки використання. Розглянуто UML-діаграму, що демонструє взаємодію елементів і відвідувачів. Для закріплення теоретичного матеріалу було продемонстровано два приклади з фрагментами коду на мові Go, де показано роботу методу Accept() та взаємодію з різними класами Visitor, а також до ті після впровадження патерну. Приклад демонструє, як за допомогою патерна можна винести бізнес-логіку за межі об'єктів, не змінюючи їхню структуру.

4.	Висновки
У результаті виконання роботи та дослідження патерна Visitor було з’ясовано, що даний патерн є ефективним рішенням для реалізації нових операцій над об’єктами без зміни їхніх класів. Це особливо корисно у випадках, коли потрібно виконувати різні дії над великою кількістю об’єктів різних типів, наприклад, у парсерах, генераторах звітів тощо. Недоліком є те, що додавання нових елементів (класів, які відвідуються) потребує змін у кожному відвідувачі. Проте Visitor забезпечує гнучкість, підтримку принципів SOLID та зменшує зв’язність у коді, що робить його важливим інструментом об’єктно-орієнтованого проєктування.













ДОДАТОК А
Хронологічний опис та посилання

Відеозапис доповіді на YouTube: https://youtu.be/btieD7-Gj8I?feature=shared

Хронологічний опис доповіді:
00:04 Вступ. Представлення себе та теми: мова йтиме про поведінковий патерн Visitor.
00:20 Опис патерна Visitor. Використання методу accept(visitor) для виклику відповідного visit().
01:03 Пояснення, коли корисний Visitor: об’єкти різних типів, багато операцій, звіти.
01:53 Пояснення структури та принципу дії патерну на діаграмі
02:43 Приклад проблеми без Visitor
03:15 Рішення проблеми через Visitor
03:51 Наведення другого прикладу без патерну Visitor: дублювання коду та погана масштабованість
04:29 Впровадження Visitor: масштабоване та гнучке рішення
05:05 Переваги та недоліки патерну Visitor
05:41 Доцільність використання патерна Visitor
06:09 Результати та висновки
06:47 Список використаних джерел









ДОДАТОК Б

Слайди презентації доповіді на тему «Патерн проєктування Visitor»

 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Опис патерна Visitor

 
Рисунок Б.3 – Опис проблеми та вирішення за допомогою Visitor

 
Рисунок Б.4 – Структура та принцип дії патерну на діаграмі





 
Рисунок Б.5 – Приклад проблеми без Visitor

 
Рисунок Б.6 – Рішення проблеми через Visitor
  



 
Рисунок Б.7 – Наведення другого прикладу без патерну Visitor

 
Рисунок Б.8 – Впровадження Visitor та перероблення фрагментів коду





 
Рисунок Б.9 – Переваги та недоліки патерну Visitor

 
Рисунок Б.10 – Доцільність використання патерна Visitor





 
Рисунок Б.11 – Результати і висновки

 
Рисунок Б.12 – Список використаних джерел





ДОДАТОК В

Програмний код на мові Go, використаний як приклад у презентації

1	// Приклад проблеми без Visitor 
2	type Patient struct {
3	name string
4	needsCheckup bool
5	needsMedication bool
6	}

7	func (p *Patient) PerformDailyCare() {
8	if p.needsCheckup {
i.	// перевірка стану
9	}
10	if p.needsMedication {
i.	// нагадування про ліки
11	}
12	}

13	// Рішення проблеми через Visitor
14	type Visitor interface {
15	VisitPatient(p *Patient)
16	}

17	type Patient struct {
18	name string
19	needsCheckup bool
20	needsMedication bool
21	}

22	func (p *Patient) Accept(v Visitor) {
23	v.VisitPatient(p)
24	}

25	// Наведення другого прикладу без патерну Visitor
26	type ElderlyPatient struct {
27	Name string
28	Age  int
29	}

30	type DisabledPatient struct {
31	Name string
32	Disability string
33	}

34	func provideCareForElderly(p ElderlyPatient) {
35	fmt.Printf("Providing elderly care to %s (age %d)\n", p.Name, p.Age)
36	}

37	func provideCareForDisabled(p DisabledPatient) {
38	fmt.Printf("Providing disability care to %s (%s)\n", p.Name, p.Disability)
39	}

40	func main() {
41	el := ElderlyPatient{"Maria", 80}
42	ds := DisabledPatient{"Ivan", "Mobility impairment"}

43	provideCareForElderly(el)
44	provideCareForDisabled(ds)
45	}

46	//Впровадження Visitor
47	// Visitor
48	type CareVisitor interface {
49	VisitElderly(*ElderlyPatient)
50	VisitDisabled(*DisabledPatient)
51	}

52	// Element
53	type Patient interface {
54	Accept(CareVisitor)
55	}

56	// ConcreteElement 1
57	type ElderlyPatient struct {
58	Name string
59	Age  int
60	}

61	func (p *ElderlyPatient) Accept(v CareVisitor) {
62	v.VisitElderly(p)
63	}

64	// ConcreteElement 2
65	type DisabledPatient struct {
66	Name       string
67	Disability string
68	}

69	func (p *DisabledPatient) Accept(v CareVisitor) {
70	v.VisitDisabled(p)
71	}

72	// ConcreteVisitor
73	type DailyCare struct{}

74	func (c *DailyCare) VisitElderly(p *ElderlyPatient) {
75	fmt.Printf("Daily care for elderly: %s, %d y.o.\n", p.Name, p.Age)
76	}

77	func (c *DailyCare) VisitDisabled(p *DisabledPatient) {
78	fmt.Printf("Daily care for disabled: %s (%s)\n", p.Name, p.Disability)
79	}

80	func main() {
81	patients := []Patient{
i.	&ElderlyPatient{Name: "Maria", Age: 80},
ii.	&DisabledPatient{Name: "Ivan", Disability: "Mobility impairment"},
82	}

83	visitor := &DailyCare{}
84	for _, p := range patients {
i.	p.Accept(visitor)
85	}
86	}

